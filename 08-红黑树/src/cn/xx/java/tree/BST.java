package cn.xx.java.tree;import java.util.Comparator;import java.util.LinkedList;import java.util.Queue;/** * 二叉搜索树 * * @author xiexu * @create 2021-07-26 12:13 下午 */public class BST<E> extends BinaryTree<E> {    private Comparator<E> comparator;    public BST() {        this(null);    }    public BST(Comparator<E> comparator) {        this.comparator = comparator;    }    private void elementNotNullCheck(E element) {        if (element == null) {            throw new IllegalArgumentException("element must not be null");        }    }    /**     * 添加元素     *     * @param element     */    public void add(E element) {        //判空        elementNotNullCheck(element);        //根节点为空，相当于添加第一个节点        if (root == null) {            root = createNode(element, null);            size++;            //新添加节点之后的处理            afterAdd(root);            return;        }        //添加的不是第一个节点        //找到父节点        Node<E> parent = root;        Node<E> node = root;        int cmp = 0;        while (node != null) {            cmp = commpare(element, node.element);            parent = node;            if (cmp > 0) {                node = node.right;            } else if (cmp < 0) {                node = node.left;            } else { //相等直接返回                node.element = element;                return;            }        }        //找到父节点，看看插入到父节点的哪个位置        Node<E> newNode = createNode(element, parent); //创建新节点        if (cmp > 0) {            parent.right = newNode;        } else {            parent.left = newNode;        }        size++;        //新添加节点之后的处理        afterAdd(newNode);    }    /**     * 添加node之后的调整     *     * @param node 新添加的节点     */    protected void afterAdd(Node<E> node) {    }    /**     * 删除node之后的调整     *     * @param node 被删除的节点 或者 用以取代被删除节点的子节点（当被删除节点的度为1）     */    protected void afterRemove(Node<E> node) {    }    public void remove(E element) {        remove(node(element));    }    private void remove(Node<E> node) {        if (node == null) {            return;        }        size--;        if (node.hasTwoChildren()) { //度为2的节点            //找到后继节点            Node<E> s = successor(node);            //用后继节点的值，覆盖度为2的节点的值            node.element = s.element;            //删除后继节点            node = s;        }        //删除node节点（node的度必然是1或者0）        Node<E> replacement = node.left != null ? node.left : node.right;        if (replacement != null) { //node是度为1的节点            //更改parent            replacement.parent = node.parent;            //更改parent的left，right的指向            if (node.parent == null) { //node是度为1的节点并且是根节点                root = replacement;            } else {                if (node == node.parent.left) {                    node.parent.left = replacement;                } else { //node == node.parent.right                    node.parent.right = replacement;                }            }            //删除节点之后的处理            afterRemove(replacement);        } else if (node.parent == null) { //node是叶子节点并且是根节点            root = null;            //删除节点之后的处理            afterRemove(node);        } else { //node是叶子节点，但不是根节点            if (node == node.parent.left) {                node.parent.left = null;            } else { //node == node.parent.right                node.parent.right = null;            }            //删除节点之后的处理            afterRemove(node);        }    }    private Node<E> node(E element) {        Node<E> node = root;        while (node != null) {            int cmp = commpare(element, node.element);            if (cmp == 0) {                return node;            } else if (cmp > 0) {                node = node.right;            } else { //cmp < 0                node = node.left;            }        }        return null;    }    /**     * 判断元素是否存在     *     * @param element     * @return     */    public boolean contains(E element) {        return node(element) != null;    }    /**     * @param e1     * @param e2     * @return 返回值等于0，代表e1和e2相等；返回值大于0，代表e1大于e2；返回值小于0，代表e1小于e2     */    private int commpare(E e1, E e2) {        if (comparator != null) {            return comparator.compare(e1, e2);        } else {            return ((Comparable<E>) e1).compareTo(e2);        }    }    /**     * 前序遍历     */    public void preorderTraversal() {        preorderTraversal(root);    }    private void preorderTraversal(Node<E> node) {        if (node == null) {            return;        }        //先访问根节点        System.out.println(node.element);        //访问左子节点        preorderTraversal(node.left);        //访问右子节点        preorderTraversal(node.right);    }    /**     * 中序遍历     */    public void inorderTraversal() {        inorderTraversal(root);    }    private void inorderTraversal(Node<E> node) {        if (node == null) {            return;        }        //先中序遍历左子树        inorderTraversal(node.left);        //输出根节点        System.out.println(node.element);        //再中序遍历右子树        inorderTraversal(node.right);    }    /**     * 后序遍历     */    public void postorderTraversal() {        postorderTraversal(root);    }    private void postorderTraversal(Node<E> node) {        if (node == null) {            return;        }        //先遍历左子树        postorderTraversal(node.left);        //再遍历右子树        postorderTraversal(node.right);        //最后访问根节点        System.out.println(node.element);    }    /**     * 层序遍历     */    public void levelOrderTranversal() {        if (root == null) {            return;        }        Queue<Node<E>> queue = new LinkedList<>();        //将头节点入队        queue.offer(root);        while (!queue.isEmpty()) {            //将头结点出队            Node<E> node = queue.poll();            System.out.println(node.element);            //如果左子节点不为空，就将左子节点入队            if (node.left != null) {                queue.offer(node.left);            }            //如果右子节点不为空，就将右子节点入队            if (node.right != null) {                queue.offer(node.right);            }        }    }}