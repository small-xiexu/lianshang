package cn.xx.java;import cn.xx.java.printer.BinaryTreeInfo;import java.util.Comparator;import java.util.LinkedList;import java.util.Queue;/** * @author xiexu * @create 2021-07-26 12:13 下午 */public class BinarySearchTree<E> implements BinaryTreeInfo {    private int size; //节点数量    private Node<E> root; //根节点    private Comparator<E> comparator;    public BinarySearchTree() {        this(null);    }    public BinarySearchTree(Comparator<E> comparator) {        this.comparator = comparator;    }    public int size() {        return size;    }    public boolean isEmpty() {        return size == 0;    }    public void clear() {        root = null;        size = 0;    }    private void elementNotNullCheck(E element) {        if (element == null) {            throw new IllegalArgumentException("element must not be null");        }    }    /**     * 前驱节点: 中序遍历时的前一个节点     * 求前驱节点     */    private Node<E> predecessor(Node<E> node) {        if (node == null) {            return null;        }        //前驱节点在左子树中(left.right.right.right....)        Node<E> p = node.left;        if (node.left != null) {            //左子树不为空，则找到它的最右节点            while (p.right != null) {                p = p.right;            }            return p;        }        // 能来到这里说明左子树为空, 则从父节点、祖父节点中寻找前驱节点        // 当父节点不为空, 且某节点为父节点的左子节点        // 则顺着父节点找, 直到找到【某结点为父节点或祖父节点的右子树中】时        while (node.parent != null && node.parent.left == node) {            node = node.parent;        }        // 来到这里有以下两种情况:        // node.parent == null	无前驱, 说明是根结点        // node.parent...right == node 找到【某结点为父节点或祖父节点的右子树中】        // 那么父节点就是某节点的前驱节点        return node.parent;    }    /**     * 后继节点: 中序遍历时的后一个节点     * 求后继节点     */    private Node<E> successor(Node<E> node) {        if (node == null) {            return null;        }        //后继节点在右子树中(right.left.left.left....)        Node<E> p = node.right;        if (node.right != null) {            //左子树不为空，则找到它的最右节点            while (p.left != null) {                p = p.left;            }            return p;        }        // 能来到这里说明右子树为空, 则从父节点、祖父节点中寻找后继节点        // 当父节点不为空, 且某节点为父节点的右子节点        // 则顺着父节点找, 直到找到【某结点为父节点或祖父节点的左子树中】时        while (node.parent != null && node.parent.right == node) {            node = node.parent;        }        // 来到这里有以下两种情况:        // node.parent == null	无后继, 说明是根结点        // node.parent...left == node 找到【某结点为父节点或祖父节点的左子树中】        // 那么父节点就是某节点的后继节点        return node.parent;    }    /**     * 添加元素     *     * @param element     */    public void add(E element) {        elementNotNullCheck(element);        //根节点为空，相当于添加第一个节点        if (root == null) {            root = new Node<>(element, null);            size++;            return;        }        //添加的不是第一个节点        //找到父节点        Node<E> parent = root;        Node<E> node = root;        int cmp = 0;        while (node != null) {            cmp = commpare(element, node.element);            parent = node;            if (cmp > 0) {                node = node.right;            } else if (cmp < 0) {                node = node.left;            } else { //相等直接返回                node.element = element;                return;            }        }        //找到父节点，看看插入到父节点的哪个位置        Node<E> newNode = new Node<>(element, parent); //创建新节点        if (cmp > 0) {            parent.right = newNode;        } else {            parent.left = newNode;        }        size++;    }    public void remove(E element) {        remove(node(element));    }    private void remove(Node<E> node) {        if (node == null) {            return;        }        size--;        if (node.hasTwoChildren()) { //度为2的节点            //找到后继节点            Node<E> s = successor(node);            //用后继节点的值，覆盖度为2的节点的值            node.element = s.element;            //删除后继节点            node = s;        }        //删除node节点（node的度必然是1或者0）        Node<E> replacement = node.left != null ? node.left : node.right;        if (replacement != null) { //node是度为1的节点            //更改parent            replacement.parent = node.parent;            //更改parent的left，right的指向            if (node.parent == null) { //node是度为1的节点并且是根节点                root = replacement;            } else {                if (node == node.parent.left) {                    node.parent.left = replacement;                } else { //node == node.parent.right                    node.parent.right = replacement;                }            }        } else if (node.parent == null) { //node是叶子节点并且是根节点            root = null;        } else { //node是叶子节点，但不是根节点            if (node == node.parent.left) {                node.parent.left = null;            } else { //node == node.parent.right                node.parent.right = null;            }        }    }    private Node<E> node(E element) {        Node<E> node = root;        while (node != null) {            int cmp = commpare(element, node.element);            if (cmp == 0) {                return node;            } else if (cmp > 0) {                node = node.right;            } else { //cmp < 0                node = node.left;            }        }        return null;    }    /**     * 判断元素是否存在     *     * @param element     * @return     */    public boolean contains(E element) {        return node(element) != null;    }    /**     * @param e1     * @param e2     * @return 返回值等于0，代表e1和e2相等；返回值大于0，代表e1大于e2；返回值小于0，代表e1小于e2     */    private int commpare(E e1, E e2) {        if (comparator != null) {            return comparator.compare(e1, e2);        } else {            return ((Comparable<E>) e1).compareTo(e2);        }    }    @Override    public Object root() {        return root;    }    @Override    public Object left(Object node) {        return ((Node<E>) node).left;    }    @Override    public Object right(Object node) {        return ((Node<E>) node).right;    }    @Override    public Object string(Object node) {        Node<E> myNode = (Node<E>) node;        String parentString = "null";        if (myNode.parent != null) {            parentString = myNode.parent.element.toString();        }        return ((Node<E>) node).element + "_p(" + parentString + ")";    }    private static class Node<E> {        E element;        Node<E> left; //左子节点        Node<E> right; //右子节点        Node<E> parent; //父节点        public Node(E element, Node<E> parent) {            this.element = element;            this.parent = parent;        }        //判断当前节点是不是叶子节点        public boolean isLeaf() {            return left == null && right == null;        }        //判断当前节点是不是拥有两个子节点        public boolean hasTwoChildren() {            return left != null && right != null;        }    }    /**     * 前序遍历     */    public void preorderTraversal() {        preorderTraversal(root);    }    private void preorderTraversal(Node<E> node) {        if (node == null) {            return;        }        //先访问根节点        System.out.println(node.element);        //访问左子节点        preorderTraversal(node.left);        //访问右子节点        preorderTraversal(node.right);    }    public void preorder(Visitor<E> visitor) {        if (visitor == null) {            return;        }        preorder(root, visitor);    }    private void preorder(Node<E> node, Visitor<E> visitor) {        if (node == null || visitor.stop) {            return;        }        if (visitor.stop) {            return;        }        visitor.stop = visitor.visit(node.element);        preorder(node.left, visitor);        preorder(node.right, visitor);    }    /**     * 中序遍历     */    public void inorderTraversal() {        inorderTraversal(root);    }    private void inorderTraversal(Node<E> node) {        if (node == null) {            return;        }        //先中序遍历左子树        inorderTraversal(node.left);        //输出根节点        System.out.println(node.element);        //再中序遍历右子树        inorderTraversal(node.right);    }    public void inorder(Visitor<E> visitor) {        if (visitor == null) {            return;        }        inorder(root, visitor);    }    private void inorder(Node<E> node, Visitor<E> visitor) {        if (node == null || visitor.stop) {            return;        }        inorder(node.left, visitor);        if (visitor.stop) {            return;        }        visitor.stop = visitor.visit(node.element);        inorder(node.right, visitor);    }    /**     * 后序遍历     */    public void postorderTraversal() {        postorderTraversal(root);    }    private void postorderTraversal(Node<E> node) {        if (node == null) {            return;        }        //先遍历左子树        postorderTraversal(node.left);        //再遍历右子树        postorderTraversal(node.right);        //最后访问根节点        System.out.println(node.element);    }    public void postorder(Visitor<E> visitor) {        if (visitor == null) {            return;        }        postorder(root, visitor);    }    private void postorder(Node<E> node, Visitor<E> visitor) {        if (node == null || visitor.stop) {            return;        }        postorder(node.left, visitor);        postorder(node.right, visitor);        if (visitor.stop) {            return;        }        visitor.stop = visitor.visit(node.element);    }    /**     * 层序遍历     */    public void levelOrderTranversal() {        if (root == null) {            return;        }        Queue<Node<E>> queue = new LinkedList<>();        //将头节点入队        queue.offer(root);        while (!queue.isEmpty()) {            //将头结点出队            Node<E> node = queue.poll();            System.out.println(node.element);            //如果左子节点不为空，就将左子节点入队            if (node.left != null) {                queue.offer(node.left);            }            //如果右子节点不为空，就将右子节点入队            if (node.right != null) {                queue.offer(node.right);            }        }    }    public void levelOrder(Visitor<E> visitor) {        if (root == null || visitor == null) {            return;        }        Queue<Node<E>> queue = new LinkedList<>();        //将头节点入队        queue.offer(root);        while (!queue.isEmpty()) {            //将头结点出队            Node<E> node = queue.poll();            if (visitor.visit(node.element)) {                return;            }            //如果左子节点不为空，就将左子节点入队            if (node.left != null) {                queue.offer(node.left);            }            //如果右子节点不为空，就将右子节点入队            if (node.right != null) {                queue.offer(node.right);            }        }    }    public static abstract class Visitor<E> {        boolean stop;        /**         * @param element         * @return 如果返回true，就代表停止遍历         */        abstract boolean visit(E element);    }    @Override    public String toString() {        StringBuilder sb = new StringBuilder();        toString(root, sb, "");        return sb.toString();    }    private void toString(Node<E> node, StringBuilder sb, String prefix) {        if (node == null) {            return;        }        sb.append(prefix).append(node.element).append("\n");        toString(node.left, sb, prefix + "L---");        toString(node.right, sb, prefix + "R---");    }    /**     * 计算二叉树的高度     * 非递归解法     */    public int height() {        if (root == null) {            return 0;        }        //树的高度        int height = 0;        //存储着每一层的元素数量        int levelSize = 1;        Queue<Node<E>> queue = new LinkedList<>();        //将头节点入队        queue.offer(root);        while (!queue.isEmpty()) {            //将头结点出队            Node<E> node = queue.poll();            levelSize--;            //如果左子节点不为空，就将左子节点入队            if (node.left != null) {                queue.offer(node.left);            }            //如果右子节点不为空，就将右子节点入队            if (node.right != null) {                queue.offer(node.right);            }            if (levelSize == 0) { //意味着即将要访问下一层                levelSize = queue.size();                height++;            }        }        return height;    }    /**     * 计算二叉树的高度     * 递归解法     *     * @return     */    public int height2() {        return height(root);    }    /**     * 获取某一个节点的高度     * 递归解法     *     * @param node     * @return     */    private int height(Node<E> node) {        if (node == null) {            return 0;        }        return 1 + Math.max(height(node.left), height(node.right));    }    /**     * 判断这棵二叉树是不是完全二叉树     */    public boolean isComplete() {        if (root == null) {            return false;        }        Queue<Node<E>> queue = new LinkedList<>();        //将头节点入队        queue.offer(root);        boolean leaf = false;        while (!queue.isEmpty()) {            //将头结点出队            Node<E> node = queue.poll();            //要求是叶子节点，但这个节点却不是叶子节点            if (leaf && !node.isLeaf()) {                return false;            }            if (node.left != null) {                queue.offer(node.left);            } else if (node.right != null) {                //node.left == null && node.right != null                return false;            }            if (node.right != null) {                queue.offer(node.right);            } else {                //包含下面两种情况                //node.left == null && node.right == null                //node.left != null && node.right == null                leaf = true;            }        }        return true;    }}